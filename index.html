
<script src="script.js"></script>
<script id="title" type="text/plain">Ray Tracer</script>
<script id="description" type="text/plain">Reflection, transformed objects, fog...</script>
<script id="shader" type="x-shader/x-fragment">

vec3 BLACK = vec3(0., 0., 0.);
vec3 RED   = vec3(1.0, 0., 0.);
vec3 GREEN = vec3(0., 1.0, 0.);
vec3 BLUE  = vec3(0., 0., 1.0);

vec3 AMBIENT_LIGHT_COLOR = vec3(0.5, 0.1, 0.3);
const float AMBIENT_LIGHT_FACTOR = 0.1;

vec3 LIGHT_1_COLOR = vec3(0.2, 0.2, 0.5);
vec4 LIGHT_1_DIR = normalize(vec4(-1., 3., 5., 0.));
const float LIGHT_1_INTENSITY = 0.5;

vec3 LIGHT_2_COLOR = vec3(0.7, 0.4, 0.4);
vec4 LIGHT_2_DIR = normalize(vec4(2., 1., 1., 0.));
const float LIGHT_2_INTENSITY = 0.8;

const float HALF_FOG_AT = 15.0;
const float ALL_FOG_AT = 9.0 * HALF_FOG_AT;
vec3 FOG_COLOR = vec3(0.1, 0.1, 0.12);

//----------------------------------------------------------------------

vec3 objSphere1_loc = vec3(0.5, 0., -3.);
vec3 objSphere1_scale = vec3(0.5, 0.5, 0.5);

vec3 objSphere2_loc = vec3(-1., 0.5, -3.);
vec3 objSphere2_scale = vec3(0.3, 0.9, 0.5);

vec3 objPlane1_loc = vec3(0., -2.0, 0.);
vec3 objPlane1_scale = vec3(1., 1., 1.);

vec3 objPyramid1_loc = vec3(-2.0, 1.3, -5.);
vec3 objPyramid1_scale = vec3(0.7, 1.7, 0.7);

//----------------------------------------------------------------------

const float FL = 1.0;  // focal length
const float AR = 1.0;  // aspect ratio: width / height
vec4 CAM_LOC = vec4(0., 0., FL, 1.);
vec4 CAM_DIR = normalize(vec4(0., 0., 0., 1.) - CAM_LOC);

vec4 moveOutside(vec4 loc, vec4 dir) { return loc + 0.0005 * dir; }

mat4 trs(vec3 t, vec3 s) { return mat4(s.x,0.,0.,0., 0.,s.y,0.,0., 0.,0.,s.z,0., t.x,t.y,t.z,1.); }
mat4 inv(vec3 t, vec3 s) { return trs(-t/s, 1.0/s); }

////////////////////////////////////////////////////////////////////////

int closest_object;

float surface_t;  // length to intersection
vec3  surface_c;  // color at intersection
vec3  surface_p;  // material properties of surface
vec4  surface_l;
vec4  surface_n;

int tmp_object_code;
float tmp_t;
vec4 tmp_intersection;
vec4 tmp_normal;

//----------------------------------------------------------------------

void updateIfCloser() {
    if( tmp_t < surface_t ) {
        surface_t = tmp_t;
        surface_n = tmp_normal;
        surface_l = tmp_intersection;
        closest_object = tmp_object_code;
    }
}

////////////////////////////////////////////////////////////////////////

bool intersectUnitSphere(vec4 v, vec4 w) {
    tmp_t = ALL_FOG_AT;
    float B = 2.0 * dot(w, v);
    float C = dot(v, v) - 2.0;             // subtract another 1.0 to compensate for v.w * v.w
    float d = B*B - 4.0*C;

    if( d < 0.0 ) return false;

    float t = (-B - sqrt(d)) / 2.0;        // t in sphere's coordinates
    if( t <= 0.0 ) return false;

    tmp_t = t;
    tmp_intersection = v + t * w;
    tmp_normal = vec4(tmp_intersection.xyz, 0.);
    return true;
}

//----------------------------------------------------------------------

const int ENTERS = 1;
const int EXITS = 2;
const int MISSED_INSIDE = 3;
const int MISSED_OUTSIDE = 4;
const int MISSED_BEHIND = 5;

int intersectUnitPlane(vec4 v, vec4 w, vec4 plane) {

    float lv = dot(plane, v);
    float lw = dot(plane, w);

    if( lw == 0. ) {
        if( lv <= 0. ) return MISSED_INSIDE;
        else           return MISSED_OUTSIDE;
    }

    tmp_t = -lv / lw;
    tmp_intersection = v + tmp_t * w;
    tmp_normal = vec4(plane.xyz, 0.);

    if( lw < 0. ) return ENTERS;
    else          return EXITS;
}

////////////////////////////////////////////////////////////////////////

const int objPlane1_code = 3;

vec3 objPlane1_color = BLUE;
vec3 objPlane1_properties = vec3(0.5, 2., 0.);

mat4 objPlane1_trs = trs(objPlane1_loc, objPlane1_scale);
mat4 objPlane1_inv = inv(objPlane1_loc, objPlane1_scale);

int intersectPlane1(vec4 loc, vec4 dir) {
    vec4 plane = vec4(0., 1., 0., -1.);
    int res = intersectUnitPlane( objPlane1_inv * loc, normalize(objPlane1_inv * dir), plane );
    if( res == ENTERS ) {
        tmp_intersection = objPlane1_trs * tmp_intersection;
        tmp_normal = normalize(objPlane1_trs * tmp_normal);
        tmp_t = length(loc - tmp_intersection);
        tmp_object_code = objPlane1_code;
    }
    return res;
}

////////////////////////////////////////////////////////////////////////

const int objSphere1_code = 1;

vec3 objSphere1_color = BLUE;
vec3 objSphere1_properties = vec3(0.8, 40., 0.);

mat4 objSphere1_trs = trs(objSphere1_loc, objSphere1_scale);
mat4 objSphere1_inv = inv(objSphere1_loc, objSphere1_scale);

void intersectSphere1(vec4 loc, vec4 dir) {
    if( intersectUnitSphere( objSphere1_inv * loc, normalize(objSphere1_inv * dir) ) ) {
        tmp_intersection = objSphere1_trs * tmp_intersection;
        tmp_normal = normalize(objSphere1_trs * tmp_normal);
        tmp_t = length(loc - tmp_intersection);
        tmp_object_code = objSphere1_code;
    }
}

//----------------------------------------------------------------------

const int objSphere2_code = 2;

vec3 objSphere2_color = vec3(0.2, 0.7, 0.7);
vec3 objSphere2_properties = vec3(0.4, 5., 0.5);

mat4 objSphere2_trs = trs(objSphere2_loc, objSphere2_scale);
mat4 objSphere2_inv = inv(objSphere2_loc, objSphere2_scale);

void intersectSphere2(vec4 loc, vec4 dir) {
    if( intersectUnitSphere( objSphere2_inv * loc, normalize(objSphere2_inv * dir) ) ) {
        tmp_intersection = objSphere2_trs * tmp_intersection;
        tmp_normal = normalize(objSphere2_trs * tmp_normal);
        tmp_t = length(loc - tmp_intersection);
        tmp_object_code = objSphere2_code;
    }
}

////////////////////////////////////////////////////////////////////////

const int objPyramid1_code = 5;

vec3 objPyramid1_color = vec3(0.9, 0.5, 0.7);
vec3 objPyramid1_properties = vec3(0.4, 5., 0.5);

mat4 objPyramid1_trs = trs(objPyramid1_loc, objPyramid1_scale);
mat4 objPyramid1_inv = inv(objPyramid1_loc, objPyramid1_scale);

vec4 plane1 = vec4( 1.,  1.,  0., -1.);
vec4 plane2 = vec4(-1.,  1.,  0., -1.);
vec4 plane3 = vec4( 0.,  1.,  0., -1.);
vec4 plane4 = vec4( 0., -1.,  0., -1.);
vec4 plane5 = vec4( 0.,  1.,  1., -1.);
vec4 plane6 = vec4( 0.,  1., -1., -1.);

float maxEnter;
float minExit;

vec4 tmp2_normal;

int intersectPlaneAndUpdate(vec4 v, vec4 w, vec4 plane) {
    int res = intersectUnitPlane(v, w, plane);
    if( res == MISSED_OUTSIDE ) return res;
    if( res == ENTERS && tmp_t > maxEnter ) {
        tmp2_normal = normalize(vec4(plane.xyz, 0.));
        maxEnter = tmp_t;
    } else if( res == EXITS && tmp_t < minExit ) {
        minExit = tmp_t;
    }
    return res;
}

int intersectPyramid1(vec4 loc, vec4 dir) {

    vec4 v = objPyramid1_inv * loc;
    vec4 w = normalize(objPyramid1_inv * dir);

     maxEnter = -ALL_FOG_AT;
     minExit  =  ALL_FOG_AT;

    if( intersectPlaneAndUpdate(v, w, plane1) == MISSED_OUTSIDE )  return MISSED_OUTSIDE;
    if( intersectPlaneAndUpdate(v, w, plane2) == MISSED_OUTSIDE )  return MISSED_OUTSIDE;
//    if( intersectPlaneAndUpdate(v, w, plane3) == MISSED_OUTSIDE )  return MISSED_OUTSIDE;
    if( intersectPlaneAndUpdate(v, w, plane4) == MISSED_OUTSIDE )  return MISSED_OUTSIDE;
    if( intersectPlaneAndUpdate(v, w, plane5) == MISSED_OUTSIDE )  return MISSED_OUTSIDE;
    if( intersectPlaneAndUpdate(v, w, plane6) == MISSED_OUTSIDE )  return MISSED_OUTSIDE;

    if( maxEnter < minExit ) {
        tmp_intersection = objPyramid1_trs * (v + maxEnter * w);
        tmp_normal = normalize(objPyramid1_trs * tmp2_normal);
        tmp_t = length(tmp_intersection - loc);
        tmp_object_code = objPyramid1_code;
        return ENTERS;
    }
    return MISSED_OUTSIDE;
}

////////////////////////////////////////////////////////////////////////

// this function sets
//   surface_t
//   surface_l
//   surface_n
//   closes_object

void intersectAll(vec4 loc, vec4 dir) {
    closest_object = -1;
    surface_t = ALL_FOG_AT;

    intersectSphere1(loc, dir);  updateIfCloser();

//    intersectSphere2(loc, dir);  updateIfCloser();

    if( intersectPlane1(loc, dir) == ENTERS ) updateIfCloser();

//    if( intersectPyramid1(loc, dir) == ENTERS ) updateIfCloser();
}

////////////////////////////////////////////////////////////////////////

vec3 getColor(int objCode) {
    if( objCode == objSphere1_code )  return objSphere1_color;
    if( objCode == objSphere2_code )  return objSphere2_color;
    if( objCode == objPlane1_code  )  return objPlane1_color;
    if( objCode == objPyramid1_code ) return objPyramid1_color;

    return BLACK;
}

vec3 getProperties(int objCode) {
    if( objCode == objSphere1_code )  return objSphere1_properties;
    if( objCode == objSphere2_code )  return objSphere2_properties;
    if( objCode == objPlane1_code  )  return objPlane1_properties;
    if( objCode == objPyramid1_code  )  return objPyramid1_properties;

    return vec3(0.2, 4.0, 0.);
}

vec3 lightContribution(vec4 reflectionDir, vec4 lightDir, vec3 lightColor) {

    float metallic = surface_p.x;
    float shiny = surface_p.y;

    //---- diffused ----
    vec3 cDiffuse = BLACK;
    float diffuseFactor = dot(lightDir, surface_n);
    if( diffuseFactor > 0. ) {
        // TODO: check if in shadow
        cDiffuse = surface_c * lightColor * diffuseFactor;
    }

    //---- specular ----
    vec3 cSpecular = BLACK;

    cSpecular = metallic * surface_c + (1. - metallic) * lightColor;
    cSpecular = cSpecular * pow(max(0., dot( lightDir, reflectionDir )), shiny);

    return cDiffuse + cSpecular;
}

vec3 computeDirectedLight(vec4 reflectionDir) {

    vec3 light =
    LIGHT_1_INTENSITY * lightContribution(reflectionDir, LIGHT_1_DIR, LIGHT_1_COLOR)
    +
    LIGHT_2_INTENSITY * lightContribution(reflectionDir, LIGHT_2_DIR, LIGHT_2_COLOR)
    ;

    return light;
}

vec3 computeColor(vec4 reflectionDir, int objCode) {
    // surface color
    surface_c = getColor(objCode);
    surface_p = getProperties(objCode);

    // ambient color on the surface
    vec3 ambient = AMBIENT_LIGHT_COLOR * surface_c;

    // directed color on the surface
    vec3 directed = computeDirectedLight(reflectionDir);

    // ambient + directed
    vec3 color = AMBIENT_LIGHT_FACTOR * ambient + (1. - AMBIENT_LIGHT_FACTOR) * directed;

    // adjust with fog (std = Seen Through Fog)
    float stf = pow(0.5, surface_t / HALF_FOG_AT);
    vec3 surface_color = stf * color + (1.0 - stf) * FOG_COLOR;

    return surface_color;
}

////////////////////////////////////////////////////////////////////////

vec3 simulateRay(vec4 loc, vec4 dir) {

    intersectAll(loc, dir);
    if( surface_t == ALL_FOG_AT ) return FOG_COLOR;
    return computeColor(reflect(dir, surface_n), closest_object);
}

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

mat4 makeSurfaceMatrix(float a, float b, float c, float d, float e, float f, float g, float h, float i, float j) {
    return mat4( a, 0., 0., 0.,   f, b, 0., 0.,   e, d, c, 0.,   g, h, i, j );
}

mat4 SPHERE_MATRIX   = makeSurfaceMatrix(1., 1., 1., 0., 0., 0., 0., 0., 0., -1.);
mat4 CYLINDER_MATRIX = makeSurfaceMatrix(1., 1., 0., 0., 0., 0., 0., 0., 0., -1.);
mat4 CONE_MATRIX     = makeSurfaceMatrix(1., 1., -1., 0., 0., 0., 0., 0., 0., 0.);

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

float res_t_traceToSurface;
vec4 res_normal_traceToSurface;
vec4 res_intersect_traceToSurface;

int traceToSurface(vec4 V, vec4 W, mat4 Q) {
    float a = Q[0][0];
    float b = Q[1][1];
    float c = Q[2][2];
    float d = Q[2][1];
    float e = Q[2][0];
    float f = Q[1][0];
    float g = Q[3][0];
    float h = Q[3][1];
    float i = Q[3][2];
    float j = Q[3][3];

    float A = a * W.x * W.x + b * W.y * W.y + c * W.z * W.z + d * W.y * W.z + e * W.z * W.x + f * W.x * W.y;
    float B = 2. * (a * V.x * W.x + b * V.y * W.y + c * V.z * W.z) + d * (V.y * W.z + V.z * W.y) + e * (V.z * W.x + V.x * W.z) + f * (V.x * W.y + V.y * W.x) + g * W.x + h * W.y + i * W.z;
    float C = a * V.x * V.x + b * V.y * V.y + c * V.z * V.z + d * V.y * V.z + e * V.z * V.x + f * V.x * V.y + g * V.x + h * V.y + i * V.z + j;

    float det = B * B - 4. * A * C;
    if( det < 0. )   // no intersection
        return MISSED_OUTSIDE;

    float ret1 = (- B - sqrt(det)) / (2. * A);
    float ret2 = (- B + sqrt(det)) / (2. * A);

    int res;
    if( ret1 < 0. ) {
        if( ret2 > 0. ) {
            res_t_traceToSurface = ret2;
            res = EXITS;
        } else {
            res_t_traceToSurface = max(ret1, ret2);
            res = MISSED_BEHIND;
        }
    } else {
        if( ret1 < ret2 ) {
            res_t_traceToSurface = ret1;
            res = ENTERS;
        } else {
            res_t_traceToSurface = ret2;
            res = EXITS;
        }
    }

    if( res == ENTERS || res == EXITS ) {
        res_intersect_traceToSurface = V + res_t_traceToSurface * W;
        float x = res_intersect_traceToSurface.x;
        float y = res_intersect_traceToSurface.y;
        float z = res_intersect_traceToSurface.z;
        res_normal_traceToSurface = normalize( 
            vec4(2. * a * x + e * z + f * y + g  ,  2. * b * y + d * z + f * x + h  ,  2. * c * z + d * y + e * x + i , 0. )
        );
    }

    return res;
}

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

mat4 m_identity() {
    return mat4(1., 0., 0., 0.,   0., 1., 0., 0.,   0., 0., 1., 0.,   0., 0., 0., 1.);
}

mat4 m_transpose(mat4 m) {
    return mat4(
        m[0][0], m[1][0], m[2][0], m[3][0],
        m[0][1], m[1][1], m[2][1], m[3][1],
        m[0][2], m[1][2], m[2][2], m[3][2],
        m[0][3], m[1][3], m[2][3], m[3][3]
        );
}

mat4 m_add_to_triangle(mat4 m) {
    return mat4(
        m[0][0], 0., 0., 0.,
        m[1][0] + m[0][1], m[1][1], 0., 0.,
        m[2][0] + m[0][2], m[2][1] + m[1][2], m[2][2], 0.,
        m[3][0] + m[0][3], m[3][1] + m[1][3], m[3][2] + m[2][3], m[3][3]
        );
}

mat4 m_translate(float dx, float dy, float dz) {
    return mat4(1., 0., 0., 0. , 0., 1., 0., 0. , 0., 0., 1., 0. , dx, dy, dz, 1.);
}

mat4 m_scale(float sx, float sy, float sz) {
    return mat4(sx, 0., 0., 0. , 0., sy, 0., 0. , 0., 0., sz, 0. , 0., 0., 0., 1.);
}

mat4 m_x_rotate(float theta) {
    float s = sin(theta);  float c = cos(theta);
    return mat4(1., 0., 0., 0.,   0., c, s, 0.,   0., -s, c, 0.,   0., 0., 0., 1.);
}

mat4 m_y_rotate(float theta) {
    float s = sin(theta);  float c = cos(theta);
    return mat4(c, 0., -s, 0.,   0., 1., 0., 0.,   s, 0., c, 0.,   0., 0., 0., 1.);
}

mat4 m_z_rotate(float theta) {
    float s = sin(theta);  float c = cos(theta);
    return mat4(c, s, 0., 0.,   -s, c, 0., 0.,   0., 0., 1., 0.,   0., 0., 0., 1.);
}

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
//
// m_transform_init();                                // 1. initialize forward and inverse matrices
// m_transform_translate(dx, dy, dz);                 // 2. translate
// m_transform_rotate_xyz(xTheta, yTheta, zTheta);    // 3. rotate (in that order) around x, y , z axis
// m_transform_scale(sx, sy, sz);                     // 4. scale
// m_transform_get_transformed(untransformed_matrix); // 5. get the transformed matrix
//                                                    // -- or --
// m_transform_get_fwd();                             // 5a. get forward transformation
// m_transform_get_inv();                             // 5b. get inverse transformation
//
////////////////////////////////////////////////////////////////////////

mat4 _tmp_m_fwd_, _tmp_m_inv_;  // matrices used by the functions in this section

void m_transform_init() {
    _tmp_m_fwd_ = m_identity();
    _tmp_m_inv_ = m_identity();
}

void m_transform_translate(float dx, float dy, float dz) {
    _tmp_m_fwd_ = _tmp_m_fwd_ * m_translate(dx, dy, dz);
    _tmp_m_inv_ = m_translate(-dx, -dy, -dz) * _tmp_m_inv_;
}

void m_transform_scale(float sx, float sy, float sz) {
    _tmp_m_fwd_ = _tmp_m_fwd_ * m_scale(sx, sy, sz);
    _tmp_m_inv_ = m_scale(1./sx, 1./sy, 1./sz) * _tmp_m_inv_;
}

void m_transform_rotate_x(float theta) {
    _tmp_m_fwd_ = _tmp_m_fwd_ * m_x_rotate(theta);
    _tmp_m_inv_ = m_x_rotate(-theta) * _tmp_m_inv_;
}

void m_transform_rotate_y(float theta) {
    _tmp_m_fwd_ = _tmp_m_fwd_ * m_y_rotate(theta);
    _tmp_m_inv_ = m_y_rotate(-theta) * _tmp_m_inv_;
}

void m_transform_rotate_z(float theta) {
    _tmp_m_fwd_ = _tmp_m_fwd_ * m_z_rotate(theta);
    _tmp_m_inv_ = m_z_rotate(-theta) * _tmp_m_inv_;
}

void m_transform_rotate_xyz(float thetax, float thetay, float thetaz) {
    m_transform_rotate_x(thetax);
    m_transform_rotate_y(thetay);
    m_transform_rotate_z(thetaz);
}

mat4 m_transform_get_fwd() { return _tmp_m_fwd_; }

mat4 m_transform_get_inv() { return _tmp_m_inv_; }

mat4 m_transform_get_transformed(mat4 untransformed) {
    return m_add_to_triangle( m_transpose(_tmp_m_inv_) * untransformed * _tmp_m_inv_ );
}

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

mat4 matrix_cone1;

int intCone1(vec4 V, vec4 W) {
    int status = traceToSurface(V, W, matrix_cone1);
    return status;
}

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

void main(void) {

    float screenX = vUV.x;
    float screenY = vUV.y;
    float time = uTime;

    m_transform_init();
    m_transform_translate(0.0, 0., -3.0);
    m_transform_rotate_xyz( time * 1., time * 1.5, time * 0.4);
    m_transform_scale(0.5, 0.3, 0.1);
    matrix_cone1 = m_transform_get_transformed(SPHERE_MATRIX);

    vec3 color = BLACK;
    vec4 rayDir = normalize(vec4((screenX - 0.5) * AR, screenY - 0.5, -FL, 0.0));

    int status = intCone1(CAM_LOC, rayDir);

    if( status == ENTERS ) {
        float x = -dot(res_normal_traceToSurface, rayDir);
        color = x * RED;
    }

    /*
    CAM_LOC.x += 1.  * sin(time / 3.0);
    CAM_LOC.y += 1.  * sin(time / 1.5);
    CAM_LOC.z += 3.  * sin(time / 2.0);
    //*/

    // color = simulateRay(CAM_LOC, rayDir);

    gl_FragColor = vec4(color, 1.0);
}

</script>

<script>start()</script>
