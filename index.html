
<script src="script.js"></script>
<script id="title" type="text/plain">Ray Tracer</script>
<script id="description" type="text/plain">Reflection, transformed objects, fog...</script>
<script id="shader" type="x-shader/x-fragment">

vec3 BLACK = vec3(0., 0., 0.);
vec3 RED   = vec3(1.0, 0., 0.);
vec3 GREEN = vec3(0., 1.0, 0.);
vec3 BLUE  = vec3(0., 0., 1.0);

const float HALF_FOG_AT = 15.0;
const float ALL_FOG_AT = 9.0 * HALF_FOG_AT;
vec3 FOG_COLOR = vec3(0.5, 0.5, 0.52);

//----------------------------------------------------------------------

vec3 objSphere1_loc = vec3(1., 0., -3.);
vec3 objSphere1_scale = vec3(0.5, 0.5, 0.5);

vec3 objSphere2_loc = vec3(-1., 0.5, -3.);
vec3 objSphere2_scale = vec3(0.3, 0.9, 0.5);

vec3 objPlane1_loc = vec3(0., -2.0, 0.);
vec3 objPlane1_scale = vec3(1., 1., 1.);

//----------------------------------------------------------------------

const float FL = 1.0;  // focal length
const float AR = 1.0;  // aspect ratio: width / height
vec4 CAM_LOC = vec4(0., 0., FL, 1.);
vec4 CAM_DIR = normalize(vec4(0., 0., 0., 1.) - CAM_LOC);

vec4 moveOutside(vec4 loc, vec4 dir) { return loc + 0.0005 * dir; }

mat4 trs(vec3 t, vec3 s) { return mat4(s.x,0.,0.,0., 0.,s.y,0.,0., 0.,0.,s.z,0., t.x,t.y,t.z,1.); }
mat4 inv(vec3 t, vec3 s) { return trs(-t/s, 1.0/s); }

////////////////////////////////////////////////////////////////////////

int closest_object;

float surface_t;  // length to intersection
vec3  surface_c;  // color at intersection
vec4  surface_l;
vec4  surface_n;

int tmp_object_code;
float tmp_t;
vec4 tmp_intersection;
vec4 tmp_normal;

//----------------------------------------------------------------------

void updateIfCloser() {
    if( tmp_t < surface_t ) {
        surface_t = tmp_t;
        surface_n = tmp_normal;
        surface_l = tmp_intersection;
        closest_object = tmp_object_code;
    }
}

////////////////////////////////////////////////////////////////////////

bool intersectUnitSphere(vec4 v, vec4 w) {
    tmp_t = ALL_FOG_AT;
    float B = 2.0 * dot(w, v);
    float C = dot(v, v) - 2.0;             // subtract another 1.0 to compensate for v.w * v.w
    float d = B*B - 4.0*C;

    if( d < 0.0 ) return false;

    float t = (-B - sqrt(d)) / 2.0;        // t in sphere's coordinates
    if( t <= 0.0 ) return false;

    tmp_t = t;
    tmp_intersection = v + t * w;
    tmp_normal = vec4(tmp_intersection.xyz, 0.);
    return true;
}

//----------------------------------------------------------------------

const int ENTERS = 1;
const int EXITS = 2;
const int MISSED_INSIDE = 3;
const int MISSED_OUTSIDE = 4;

int intersectUnitPlane(vec4 v, vec4 w, vec4 plane) {

    float lv = dot(plane, v);
    float lw = dot(plane, w);

    if( lw == 0. ) {
        if( lv <= 0. ) return MISSED_INSIDE;
        else           return MISSED_OUTSIDE;
    }

    tmp_t = -lv / lw;
    tmp_intersection = v + tmp_t * w;
    tmp_normal = vec4(-plane.xyz, 0.);

    if( lw < 0. ) return ENTERS;
    else          return EXITS;
}

////////////////////////////////////////////////////////////////////////

const int objPlane1_code = 3;

vec3 objPlane1_color = RED;

mat4 objPlane1_trs = trs(objPlane1_loc, objPlane1_scale);
mat4 objPlane1_inv = inv(objPlane1_loc, objPlane1_scale);

int intersectPlane1(vec4 loc, vec4 dir) {
    vec4 plane = vec4(0., 1., 0., -1.);
    int res = intersectUnitPlane( objPlane1_inv * loc, normalize(objPlane1_inv * dir), plane );
    if( res == ENTERS ) {
        tmp_intersection = objPlane1_trs * tmp_intersection;
        tmp_normal = objPlane1_trs * tmp_normal;
        tmp_t = length(loc - tmp_intersection);
        tmp_object_code = objPlane1_code;
    }
    return res;
}

////////////////////////////////////////////////////////////////////////

const int objSphere1_code = 1;

vec3 objSphere1_color = BLUE;

mat4 objSphere1_trs = trs(objSphere1_loc, objSphere1_scale);
mat4 objSphere1_inv = inv(objSphere1_loc, objSphere1_scale);

void intersectSphere1(vec4 loc, vec4 dir) {
    if( intersectUnitSphere( objSphere1_inv * loc, normalize(objSphere1_inv * dir) ) ) {
        tmp_intersection = objSphere1_trs * tmp_intersection;
        tmp_normal = objSphere1_trs * tmp_normal;
        tmp_t = length(loc - tmp_intersection);
        tmp_object_code = objSphere1_code;
    }
}

//----------------------------------------------------------------------

const int objSphere2_code = 2;

vec3 objSphere2_color = GREEN;

mat4 objSphere2_trs = trs(objSphere2_loc, objSphere2_scale);
mat4 objSphere2_inv = inv(objSphere2_loc, objSphere2_scale);

void intersectSphere2(vec4 loc, vec4 dir) {
    if( intersectUnitSphere( objSphere2_inv * loc, normalize(objSphere2_inv * dir) ) ) {
        tmp_intersection = objSphere2_trs * tmp_intersection;
        tmp_normal = objSphere2_trs * tmp_normal;
        tmp_t = length(loc - tmp_intersection);
        tmp_object_code = objSphere2_code;
    }
}

////////////////////////////////////////////////////////////////////////

// this function sets
//   surface_t
//   surface_l
//   surface_n
//   closes_object

void intersectAll(vec4 loc, vec4 dir) {
    closest_object = -1;
    surface_t = ALL_FOG_AT;

    intersectSphere1(loc, dir);
    updateIfCloser();

    intersectSphere2(loc, dir);
    updateIfCloser();

    if( intersectPlane1(loc, dir) == ENTERS ) updateIfCloser();
}

////////////////////////////////////////////////////////////////////////

vec3 getColor(int objCode) {
    if( objCode == objSphere1_code )  return objSphere1_color;
    if( objCode == objSphere2_code )  return objSphere2_color;
    if( objCode == objPlane1_code  )  return objPlane1_color;

    return BLACK;
}

////////////////////////////////////////////////////////////////////////

vec3 simulateRay(vec4 loc, vec4 dir) {

    intersectAll(loc, dir);
    if( surface_t == ALL_FOG_AT ) return FOG_COLOR;
    return getColor(closest_object);
}

////////////////////////////////////////////////////////////////////////

void main(void) {

    float screenX = vUV.x;
    float screenY = vUV.y;
    float time = uTime;

    vec3 color = BLACK;
    vec4 rayDir = normalize(vec4((screenX - 0.5) * AR, screenY - 0.5, -FL, 0.0));

    /*
    CAM_LOC.x += 1.  * sin(time / 3.0);
    CAM_LOC.y += 1.  * sin(time / 1.5);
    CAM_LOC.z += 3.  * sin(time / 2.0);
    //*/

    color = simulateRay(CAM_LOC, rayDir);

    gl_FragColor = vec4(color, 1.0);
}

</script>

<script>start()</script>
