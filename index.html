
<script src="script.js"></script>

<script id="title" type="text/plain">Ray Tracer</script>

<script id="description" type="text/plain">
Two lights, three spheres, three level deep reflection (1 original ray + 3 reflected)
</script>

<script id="shader" type="x-shader/x-fragment">

vec3 BLACK = vec3(0., 0., 0.);
vec3 RED = vec3(1.0, 0., 0.);
vec3 GREEN = vec3(0., 1.0, 0.);
vec3 BLUE = vec3(0., 0., 1.0);

float INFINITE_DISTANCE = 10000000000000000000000000000000000000.;   // TODO: probably a better way to do this because programmers are smart and include upper limit values in their libraries somehow?

const int NUM_SPHERES = 1;
uniform mat4 trsSpheres[NUM_SPHERES];
uniform mat4 trsInvSpheres[NUM_SPHERES];
uniform vec3 colSpheres[NUM_SPHERES];
uniform vec3 colPropSpheres[NUM_SPHERES];

const int NUM_INFINITE_LIGHTS = 2;



uniform vec4 infiniteLights[NUM_INFINITE_LIGHTS];

uniform float AMBIENT_REFLECTANCE;

float fl = 1.0;  // focal length
float ar = 1.0;  // aspect ratio: width / height

vec4 eye_l = vec4(0., 0., fl, 1.);
vec4 lookAt_l = vec4(0., 0., 0., 1.);
vec4 eye_d = normalize(lookAt_l - eye_l);



// Returns t (for p = v + tw) if intersection exists, otherwise returns INFINITE_DISTANCE.
// Pre-condition: dir is normalized.
float intersectSphere(vec3 loc, vec3 dir, vec3 center, float radius) {
    // dir must be normalized, so A = dir * dir will always be 1.
    float B = 2.0 * dot(dir, (loc - center));
    float C = dot(loc-center, loc-center) - radius * radius;

    float d = B*B - 4.0*C;
    if (d < 0.0) return INFINITE_DISTANCE; else return (-B - sqrt(d)) / 2.0;
}

float surface_t, surface_t_backup;   // distance t
vec3  surface_l, surface_l_backup;   // loc
vec3  surface_n, surface_n_backup;   // normal
vec3  surface_c, surface_c_backup;   // color
vec3  surface_p, surface_p_backup;   // color properties (shiny, metallic, tranparent)

void stashSurface() {
    surface_t_backup = surface_t;
    surface_l_backup = surface_l;
    surface_n_backup = surface_n;
    surface_c_backup = surface_c;
    surface_p_backup = surface_p;
}

void popSurfaceStash() {
    surface_t = surface_t_backup;
    surface_l = surface_l_backup;
    surface_n = surface_n_backup;
    surface_c = surface_c_backup;
    surface_p = surface_p_backup;
}

/*
// sets surface_t, surface_l, surface_n, surface_c
float intersectAll(vec4 loc, vec4 dir) {

    mat4 TRS = mat4(1.,0.,0.,0.,  0.,1.,0.,0.,  0.,0.,1.,0.,  0.5,0.,0.,1.);
    mat4 INV = mat4(1.,0.,0.,0.,  0.,1.,0.,0.,  0.,0.,1.,0., -0.5,0.,0.,1.);

    surface_t = INFINITE_DISTANCE;

    vec4 s_loc = INV * loc;
    vec4 s_dir = normalize(INV * dir);

    float B = 2.0 * dot(s_dir, s_loc);
    float C = dot(s_loc, s_loc) - 1.0;
    float d = B*B - 4.0*C;

        

    if( d >= 0.0 ) {
        return 1.0;

        float s_tPrime = (-B - sqrt(d) / 2.0);

        vec4 s_intesrsectsAt = s_loc + s_tPrime * s_dir;
        vec4 s_normal = vec4(s_intesrsectsAt.xyz, 0.0);
        vec4 intersectsAt = TRS * s_intesrsectsAt;
        float tPrime = length(intersectsAt - loc);
        surface_t = tPrime;

    }

    return surface_t;
}
*/
/*
float intersectAllWithBackup(vec4 loc, vec4 dir) {
    stashSurface();
    float ret = intersectAll(loc, dir);
    popSurfaceStash();
    return ret;
}

vec3 fixIntersectionPoint(vec3 loc, vec3 dir) {
    return loc + 0.00001 * dir;
}

vec3 computeDirectedLights( vec3 surfaceLoc,
                            vec3 surfaceNormal,
                            vec3 reflectedDir,
                            vec3 surfaceCol,
                            vec3 surfaceColProperties)
{
    float shiny    = surfaceColProperties.x;
    float metallic = surfaceColProperties.y;

    vec3 directedColor = vec3(0., 0., 0.);
    
    for (int idx = 0; idx < NUM_INFINITE_LIGHTS; ++idx) {
        
        vec3 lightDir = normalize(infiniteLights[idx].xyz);
        vec3 cDiffused = vec3(0., 0., 0.);
        
        vec3 lDiffuse = vec3(0.7, 0.7, 0.7);   //TODO: color of the light
        vec3 lSpecular = metallic * surfaceCol + (1. - metallic) * lDiffuse;

        if( dot(lightDir, surfaceNormal) > 0.0 ) {
            vec4 s = vec4(fixIntersectionPoint(surfaceLoc, lightDir), 1.0);
            if( intersectAllWithBackup(s, vec4(lightDir, 0.0)) != INFINITE_DISTANCE ) { continue; }

            // diffused light
            cDiffused = lDiffuse * dot( surfaceNormal, lightDir );
        }

        // specular light
        vec3 cSpecular = lSpecular * pow(max(0., dot( lightDir, reflectedDir )), shiny);
        
        //                    intensity        *       sum_of_colors
        directedColor += infiniteLights[idx].w * (cDiffused + cSpecular);
    };
    
    return directedColor;
}
vec3 computeColor( vec3 surfaceLoc,
                   vec3 surfaceNormal,
                   vec3 reflectedDir,
                   vec3 surfaceCol,
                   vec3 surfaceColProperties)
{
    vec3 ambientColor  = surfaceCol.xyz;
    vec3 diffusedColor = computeDirectedLights(surfaceLoc, surfaceNormal, reflectedDir, surfaceCol, surfaceColProperties);

    return
    AMBIENT_REFLECTANCE         * ambientColor +
    (1.0 - AMBIENT_REFLECTANCE) * diffusedColor;
}
*/

// returns color and saves intersection info in surface_... variables
/*
vec3 simulateRay(vec4 loc, vec4 dir) {
    vec3 color = vec3(0., 0., 0.);

    if( intersectAll(loc, dir) != INFINITE_DISTANCE ) {
        return vec3(0.7, 0.2, 0.2);

        //vec4 reflectionDir = reflect(dir, vec4(surface_n, 1.0));
        //color = computeColor( surface_l, surface_n, reflectionDir.xyz, surface_c, surface_p );
    }

    return color;
}
*/

vec4 res_intersectSphere_point;
vec4 res_intersectSphere_normal;

void intersectAllSpheres(vec4 loc, vec4 dir) {

    for (int i = 0; i < NUM_SPHERES; i++) {
        mat4 INV = trsInvSpheres[i];

        vec3 v = (INV * loc).xyz;
        vec3 w = normalize(INV * dir).xyz;

        float B = 2.0 * dot(w, v);
        float C = dot(v, v) - 1.0;
        float d = B*B - 4.0*C;

        if( d < 0.0 ) continue;  // missed it

        float t = (-B - sqrt(d)) / 2.0;        // t in sphere's coordinates
        if( t <= 0.0 ) continue;               // behind us

        vec3 p = v + t * w;  // intersection point in sphere's coordinates
        res_intersectSphere_point  = trsSpheres[i] * vec4(p, 1.);
        res_intersectSphere_normal = trsSpheres[i] * vec4(p, 0.);

        t = length(res_intersectSphere_point - loc);  // t in real coordinates

        if( t < surface_t ) {
            surface_t = t;
            surface_p = res_intersectSphere_point.xyz;
            surface_n = res_intersectSphere_normal.xyz;
            surface_c = colSpheres[i];
        }
    }
}

float intersectAll(vec4 loc, vec4 dir) {
    surface_t = INFINITE_DISTANCE;

    intersectAllSpheres(loc, dir);

    return surface_t;
}

vec3 simulateRay(vec4 loc, vec4 dir) {
    
    if( intersectAll(loc, dir) == INFINITE_DISTANCE )
        return BLACK;

    return surface_c;
}

void main(void) {

    float screenX = vUV.x;
    float screenY = vUV.y;
    float time = uTime;
    vec3 color = vec3(0., 0., 0.);
    vec4 rayDir = normalize(vec4((screenX - 0.5) * ar, screenY - 0.5, -fl, 0.0));

    float reflectionScaleFactor = 1.0;

    color = simulateRay(eye_l, rayDir);

    



    /*
    // reflection ray depth 1
    if( surface_t != INFINITE_DISTANCE ) {
        reflectionScaleFactor *= surface_p.y;
        rayDir = reflect(rayDir, surface_n);
        color += reflectionScaleFactor * simulateRay(fixIntersectionPoint(surface_l, rayDir), rayDir);
    }
    */

    gl_FragColor = vec4(color, 1.0);
}
</script>

<script>start()</script>
