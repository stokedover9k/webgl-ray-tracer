
<script src="script.js"></script>
<script id="title" type="text/plain">Ray Tracer</script>
<script id="description" type="text/plain">Reflection, transformed objects, fog...</script>
<script id="shader" type="x-shader/x-fragment">

vec3 BLACK = vec3(0., 0., 0.);
vec3 RED   = vec3(1.0, 0., 0.);
vec3 GREEN = vec3(0., 1.0, 0.);
vec3 BLUE  = vec3(0., 0., 1.0);

vec3 AMBIENT_LIGHT_COLOR = vec3(0.5, 0.1, 0.3);
const float AMBIENT_LIGHT_FACTOR = 0.1;

vec3 LIGHT_1_COLOR = vec3(0.2, 0.2, 0.5);
vec4 LIGHT_1_DIR = normalize(vec4(-1., 3., 5., 0.));
const float LIGHT_1_INTENSITY = 0.5;

vec3 LIGHT_2_COLOR = vec3(0.7, 0.4, 0.4);
vec4 LIGHT_2_DIR = normalize(vec4(2., 1., 1., 0.));
const float LIGHT_2_INTENSITY = 0.8;

const float HALF_FOG_AT = 15.0;
const float ALL_FOG_AT = 9.0 * HALF_FOG_AT;
vec3 FOG_COLOR = vec3(0.1, 0.1, 0.12);

//----------------------------------------------------------------------

vec3 objSphere1_loc = vec3(1., 0., -3.);
vec3 objSphere1_scale = vec3(0.5, 0.5, 0.5);

vec3 objSphere2_loc = vec3(-1., 0.5, -3.);
vec3 objSphere2_scale = vec3(0.3, 0.9, 0.5);

vec3 objPlane1_loc = vec3(0., -2.0, 0.);
vec3 objPlane1_scale = vec3(1., 1., 1.);

//----------------------------------------------------------------------

const float FL = 1.0;  // focal length
const float AR = 1.0;  // aspect ratio: width / height
vec4 CAM_LOC = vec4(0., 0., FL, 1.);
vec4 CAM_DIR = normalize(vec4(0., 0., 0., 1.) - CAM_LOC);

vec4 moveOutside(vec4 loc, vec4 dir) { return loc + 0.0005 * dir; }

mat4 trs(vec3 t, vec3 s) { return mat4(s.x,0.,0.,0., 0.,s.y,0.,0., 0.,0.,s.z,0., t.x,t.y,t.z,1.); }
mat4 inv(vec3 t, vec3 s) { return trs(-t/s, 1.0/s); }

////////////////////////////////////////////////////////////////////////

int closest_object;

float surface_t;  // length to intersection
vec3  surface_c;  // color at intersection
vec3  surface_p;  // material properties of surface
vec4  surface_l;
vec4  surface_n;

int tmp_object_code;
float tmp_t;
vec4 tmp_intersection;
vec4 tmp_normal;

//----------------------------------------------------------------------

void updateIfCloser() {
    if( tmp_t < surface_t ) {
        surface_t = tmp_t;
        surface_n = tmp_normal;
        surface_l = tmp_intersection;
        closest_object = tmp_object_code;
    }
}

////////////////////////////////////////////////////////////////////////

bool intersectUnitSphere(vec4 v, vec4 w) {
    tmp_t = ALL_FOG_AT;
    float B = 2.0 * dot(w, v);
    float C = dot(v, v) - 2.0;             // subtract another 1.0 to compensate for v.w * v.w
    float d = B*B - 4.0*C;

    if( d < 0.0 ) return false;

    float t = (-B - sqrt(d)) / 2.0;        // t in sphere's coordinates
    if( t <= 0.0 ) return false;

    tmp_t = t;
    tmp_intersection = v + t * w;
    tmp_normal = vec4(tmp_intersection.xyz, 0.);
    return true;
}

//----------------------------------------------------------------------

const int ENTERS = 1;
const int EXITS = 2;
const int MISSED_INSIDE = 3;
const int MISSED_OUTSIDE = 4;

int intersectUnitPlane(vec4 v, vec4 w, vec4 plane) {

    float lv = dot(plane, v);
    float lw = dot(plane, w);

    if( lw == 0. ) {
        if( lv <= 0. ) return MISSED_INSIDE;
        else           return MISSED_OUTSIDE;
    }

    tmp_t = -lv / lw;
    tmp_intersection = v + tmp_t * w;
    tmp_normal = vec4(-plane.xyz, 0.);

    if( lw < 0. ) return ENTERS;
    else          return EXITS;
}

////////////////////////////////////////////////////////////////////////

const int objPlane1_code = 3;

vec3 objPlane1_color = RED;
vec3 objPlane1_properties = vec3(0.1, 2., 0.);

mat4 objPlane1_trs = trs(objPlane1_loc, objPlane1_scale);
mat4 objPlane1_inv = inv(objPlane1_loc, objPlane1_scale);

int intersectPlane1(vec4 loc, vec4 dir) {
    vec4 plane = vec4(0., 1., 0., -1.);
    int res = intersectUnitPlane( objPlane1_inv * loc, normalize(objPlane1_inv * dir), plane );
    if( res == ENTERS ) {
        tmp_intersection = objPlane1_trs * tmp_intersection;
        tmp_normal = normalize(objPlane1_trs * tmp_normal);
        tmp_t = length(loc - tmp_intersection);
        tmp_object_code = objPlane1_code;
    }
    return res;
}

////////////////////////////////////////////////////////////////////////

const int objSphere1_code = 1;

vec3 objSphere1_color = BLUE;
vec3 objSphere1_properties = vec3(0.8, 40., 0.);

mat4 objSphere1_trs = trs(objSphere1_loc, objSphere1_scale);
mat4 objSphere1_inv = inv(objSphere1_loc, objSphere1_scale);

void intersectSphere1(vec4 loc, vec4 dir) {
    if( intersectUnitSphere( objSphere1_inv * loc, normalize(objSphere1_inv * dir) ) ) {
        tmp_intersection = objSphere1_trs * tmp_intersection;
        tmp_normal = normalize(objSphere1_trs * tmp_normal);
        tmp_t = length(loc - tmp_intersection);
        tmp_object_code = objSphere1_code;
    }
}

//----------------------------------------------------------------------

const int objSphere2_code = 2;

vec3 objSphere2_color = vec3(0.2, 0.7, 0.7);
vec3 objSphere2_properties = vec3(0.4, 5., 0.5);

mat4 objSphere2_trs = trs(objSphere2_loc, objSphere2_scale);
mat4 objSphere2_inv = inv(objSphere2_loc, objSphere2_scale);

void intersectSphere2(vec4 loc, vec4 dir) {
    if( intersectUnitSphere( objSphere2_inv * loc, normalize(objSphere2_inv * dir) ) ) {
        tmp_intersection = objSphere2_trs * tmp_intersection;
        tmp_normal = normalize(objSphere2_trs * tmp_normal);
        tmp_t = length(loc - tmp_intersection);
        tmp_object_code = objSphere2_code;
    }
}

////////////////////////////////////////////////////////////////////////

// this function sets
//   surface_t
//   surface_l
//   surface_n
//   closes_object

void intersectAll(vec4 loc, vec4 dir) {
    closest_object = -1;
    surface_t = ALL_FOG_AT;

    intersectSphere1(loc, dir);
    updateIfCloser();

    intersectSphere2(loc, dir);
    updateIfCloser();

    if( intersectPlane1(loc, dir) == ENTERS ) updateIfCloser();
}

////////////////////////////////////////////////////////////////////////

vec3 getColor(int objCode) {
    if( objCode == objSphere1_code )  return objSphere1_color;
    if( objCode == objSphere2_code )  return objSphere2_color;
    if( objCode == objPlane1_code  )  return objPlane1_color;

    return BLACK;
}

vec3 getProperties(int objCode) {
    if( objCode == objSphere1_code )  return objSphere1_properties;
    if( objCode == objSphere2_code )  return objSphere2_properties;
    if( objCode == objPlane1_code  )  return objPlane1_properties;

    return vec3(0.2, 4.0, 0.);
}

vec3 lightContribution(vec4 reflectionDir, vec4 lightDir, vec3 lightColor) {

    float metallic = surface_p.x;
    float shiny = surface_p.y;

    //---- diffused ----
    vec3 cDiffuse = BLACK;
    float diffuseFactor = dot(lightDir, surface_n);
    if( diffuseFactor > 0. ) {
        // TODO: check if in shadow
        cDiffuse = surface_c * lightColor * diffuseFactor;
    }

    //---- specular ----
    vec3 cSpecular = BLACK;

    cSpecular = metallic * surface_c + (1. - metallic) * lightColor;
    cSpecular = cSpecular * pow(max(0., dot( lightDir, reflectionDir )), shiny);

    return cDiffuse + cSpecular;
}

vec3 computeDirectedLight(vec4 reflectionDir) {

    vec3 light =
    LIGHT_1_INTENSITY * lightContribution(reflectionDir, LIGHT_1_DIR, LIGHT_1_COLOR)
    +
    LIGHT_2_INTENSITY * lightContribution(reflectionDir, LIGHT_2_DIR, LIGHT_2_COLOR)
    ;

    return light;
}

vec3 computeColor(vec4 reflectionDir, int objCode) {
    // surface color
    surface_c = getColor(objCode);
    surface_p = getProperties(objCode);

    // ambient color on the surface
    vec3 ambient = AMBIENT_LIGHT_COLOR * surface_c;

    // directed color on the surface
    vec3 directed = computeDirectedLight(reflectionDir);

    // ambient + directed
    vec3 color = AMBIENT_LIGHT_FACTOR * ambient + (1. - AMBIENT_LIGHT_FACTOR) * directed;

    // adjust with fog (std = Seen Through Fog)
    float stf = pow(0.5, surface_t / HALF_FOG_AT);
    vec3 surface_color = stf * color + (1.0 - stf) * FOG_COLOR;

    return surface_color;
}

////////////////////////////////////////////////////////////////////////

vec3 simulateRay(vec4 loc, vec4 dir) {

    intersectAll(loc, dir);
    if( surface_t == ALL_FOG_AT ) return FOG_COLOR;
    return computeColor(reflect(dir, surface_n), closest_object);
}

////////////////////////////////////////////////////////////////////////

void main(void) {

    float screenX = vUV.x;
    float screenY = vUV.y;
    float time = uTime;

    vec3 color = BLACK;
    vec4 rayDir = normalize(vec4((screenX - 0.5) * AR, screenY - 0.5, -FL, 0.0));

    /*
    CAM_LOC.x += 1.  * sin(time / 3.0);
    CAM_LOC.y += 1.  * sin(time / 1.5);
    CAM_LOC.z += 3.  * sin(time / 2.0);
    //*/

    color = simulateRay(CAM_LOC, rayDir);

    gl_FragColor = vec4(color, 1.0);
}

</script>

<script>start()</script>
